{"meta":{"title":"看风景的游客甲","subtitle":null,"description":"我自己觉得很赞","author":"看风景的游客甲","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2021-04-02T05:57:41.000Z","updated":"2021-04-02T06:00:29.809Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-04-07T08:31:07.000Z","updated":"2021-04-08T01:15:02.229Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"推荐网站:https://cloud12156.github.io"},{"title":"朋友圈","date":"2021-02-11T10:09:00.000Z","updated":"2021-02-13T14:47:33.171Z","comments":true,"path":"fcircle/index.html","permalink":"http://example.com/fcircle/index.html","excerpt":"","text":""},{"title":"友人帐","date":"2020-08-14T00:50:42.000Z","updated":"2021-04-26T00:30:38.103Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-02T05:56:52.000Z","updated":"2021-04-02T06:00:50.917Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringMVC笔记","slug":"SpringMVC","date":"2021-04-27T10:51:02.739Z","updated":"2021-04-27T11:03:10.520Z","comments":true,"path":"2021/04/27/SpringMVC/","link":"","permalink":"http://example.com/2021/04/27/SpringMVC/","excerpt":"","text":"SpringMVC1、回顾MVC1.1、什么是MVC MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。 是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合。 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。 最典型的MVC就是JSP + servlet + javabean的模式。 1.2、Model1时代 在web早期的开发中，通常采用的都是Model1。 Model1中，主要分为两层，视图层和模型层。 Model1优点：架构简单，比较适合小型项目开发； Model1缺点：JSP职责不单一，职责过重，不便于维护； 1.3、Model2时代Model2把一个项目分成三部分，包括视图、控制、模型。 用户发请求 Servlet接收请求数据，并调用对应的业务逻辑方法 业务处理完毕，返回更新后的数据给servlet servlet转向到JSP，由JSP来渲染页面 响应给前端更新后的页面 职责分析： Controller：控制器 取得表单数据 调用业务逻辑 转向指定的页面 Model：模型 业务逻辑 保存数据的状态 View：视图 显示页面 Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。 1.4、回顾Servlet 新建一个Maven工程当做父工程！pom依赖！ 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！ 导入servlet 和 jsp 的 jar 依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt; 编写一个Servlet类，用来处理用户的请求 123456789101112131415161718192021222324package com.kuang.servlet;//实现Servlet接口public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //取得参数 String method = req.getParameter(&quot;method&quot;); if (method.equals(&quot;add&quot;))&#123; req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;); &#125; if (method.equals(&quot;delete&quot;))&#123; req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了delete方法&quot;); &#125; //业务逻辑 //视图跳转 req.getRequestDispatcher(&quot;/WEB-INF/jsp/hello.jsp&quot;).forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req,resp); &#125;&#125; 编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 在web.xml中注册Servlet 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/user&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置Tomcat，并启动测试 localhost:8080/user?method=add localhost:8080/user?method=delete MVC框架要做哪些事情 将url映射到java类或java类的方法 . 封装用户提交的数据 . 处理请求–调用相关的业务处理–封装响应数据 . 将响应的数据进行渲染 . jsp / html 等表示层数据 . 说明： ​ 常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等…. 2、什么是SpringMVC2.1、概述 Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。 查看官方文档：https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web 我们为什么要学习SpringMVC呢? Spring MVC的特点： 轻量级，简单易学 高效 , 基于请求响应的MVC框架 与Spring兼容性好，无缝结合 约定优于配置 功能强大：RESTful、数据验证、格式化、本地化、主题等 简洁灵活 Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁； 正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 . 最重要的一点还是用的人多 , 使用的公司多 . 2.2、中心控制器​ Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。 ​ Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。 SpringMVC的原理如下图所示： ​ 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 2.3、SpringMVC执行原理 图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 简要分析执行流程 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。 HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 Handler让具体的Controller执行。 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户。 第一个MVC程序 Hello，SpringMVC 在上一节中，我们讲解了 什么是SpringMVC以及它的执行原理！ 狂神说SpringMVC01：什么是SpringMVC 现在我们来看看如何快速使用SpringMVC编写我们的程序吧！ 配置版1、新建一个Moudle ， springmvc-02-hello ， 添加web的支持！ 2、确定导入了SpringMVC 的依赖！ 3、配置web.xml ， 注册DispatcherServlet 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别-1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 4、编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml 说明，这里的名称要求是按照官方来的 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 5、添加 处理映射器 1&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; 6、添加 处理器适配器 1&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; 7、添加 视图解析器 1&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 8、编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； 12345678910111213141516package com.kuang.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//注意：这里我们先导入Controller接口public class HelloController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //ModelAndView 模型和视图 ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。Model mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC!&quot;); //封装要跳转的视图，放在ModelAndView中 mv.setViewName(&quot;hello&quot;); //: /WEB-INF/jsp/hello.jsp return mv; &#125; &#125; 9、将自己的类交给SpringIOC容器，注册bean 1&lt;!--Handler--&gt;&lt;bean id=&quot;/hello&quot; class=&quot;com.kuang.controller.HelloController&quot;/&gt; 10、写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面； 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Kuangshen&lt;/title&gt; &lt;/head&gt; &lt;body&gt; $&#123;msg&#125; &lt;/body&gt;&lt;/html&gt; 11、配置Tomcat 启动测试！ 可能遇到的问题：访问出现404，排查步骤： 查看控制台输出，看一下是不是缺少了什么jar包。 如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！ 重启Tomcat 即可解决！ 小结：看这个估计大部分同学都能理解其中的原理了，但是我们实际开发才不会这么写，不然就疯了，还学这个玩意干嘛！我们来看个注解版实现，这才是SpringMVC的精髓，到底有多么简单，看这个图就知道了。 注解版1、新建一个Moudle，springmvc-03-hello-annotation 。添加web支持！ 2、由于Maven可能存在资源过滤的问题，我们将配置完善 1&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt; &lt;includes&gt; &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt; &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt; &lt;&#x2F;includes&gt; &lt;filtering&gt;false&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;resource&gt; &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt; &lt;includes&gt; &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt; &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt; &lt;&#x2F;includes&gt; &lt;filtering&gt;false&lt;&#x2F;filtering&gt; &lt;&#x2F;resource&gt; &lt;&#x2F;resources&gt;&lt;&#x2F;build&gt; 3、在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 4、配置web.xml 注意点： 1234&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot; version&#x3D;&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt; &lt;&#x2F;servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt;&lt;&#x2F;web-app&gt; / 和 /* 的区别：&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 注意web.xml版本问题，要最新版！ 注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1 映射路径为 / 【不要用/*，会404】 5、添加Spring MVC配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： ``` 1234567891011121314151617181920212223245. 在视图解析器中我们把所有的视图都存放在&#x2F;WEB-INF&#x2F;目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。6. - 让IOC的注解生效 - 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 ..... - MVC的注解驱动 - 配置视图解析器 7. **6、创建Controller**8. 编写一个Java控制类：com.kuang.controller.HelloController , 注意编码规范9. - 10. &#96;&#96;&#96; package com.kuang.controller; import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping; @Controller@RequestMapping(&quot;&#x2F;HelloController&quot;)public class HelloController &#123; &#x2F;&#x2F;真实访问地址 : 项目名&#x2F;HelloController&#x2F;hello @RequestMapping(&quot;&#x2F;hello&quot;) public String sayHello(Model model)&#123; &#x2F;&#x2F;向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;); &#x2F;&#x2F;web-inf&#x2F;jsp&#x2F;hello.jsp return &quot;hello&quot;; &#125;&#125; @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 7、创建视图层 在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息； 可以通过EL表示取出Model中存放的值，或者对象； ```&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt; SpringMVC${msg} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263**8、配置Tomcat运行**配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！![图片](640)**OK，运行成功！**### 小结实现步骤其实非常的简单：1. 新建一个web项目2. 导入相关jar包3. 编写web.xml , 注册DispatcherServlet4. 编写springmvc配置文件5. 接下来就是去创建对应的控制类 , controller6. 最后完善前端视图和controller之间的对应7. 测试运行调试.使用springMVC必须配置的三大件：**处理器映射器、处理器适配器、视图解析器**通常，我们只需要**手动配置视图解析器**，而**处理器映射器**和**处理器适配器**只需要开启**注解驱动**即可，而省去了大段的xml配置## RestFul和控制器![图片](640)控制器Controller在上一节中，我们编写了我们的第一个SpringMVC程序！[狂神说SpringMVC02：第一个MVC程序](http:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s?__biz&#x3D;Mzg2NTAzMTExNg&#x3D;&#x3D;&amp;mid&#x3D;2247483978&amp;idx&#x3D;1&amp;sn&#x3D;6711110a3b2595d6bb987ca02ee0a728&amp;chksm&#x3D;ce6104e9f9168dffb600f71f97f89c5581923948746b7e2e53a8f0287419ea9940e124c39b0e&amp;scene&#x3D;21#wechat_redirect)现在我们来看看里面的控制器和路径请求的具体内容吧！### 控制器Controller- 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。- 控制器负责解析用户的请求并将其转换为一个模型。- 在Spring MVC中一个控制器类可以包含多个方法- 在Spring MVC中，对于Controller的配置方式有很多种 ### 实现Controller接口Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； //实现该接口的类获得控制器功能public interface Controller {//处理请求且返回一个模型与视图对象ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;} 12345678910**测试**1. 新建一个Moudle，springmvc-04-controller 。将刚才的03 拷贝一份, 我们进行操作！2. - 删掉HelloController - mvc的配置文件只留下 视图解析器！3. 编写一个Controller类，ControllerTest1 //定义控制器//注意点：不要导错包，实现Controller接口，重写方法；public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;Test1Controller&quot;); mv.setViewName(&quot;test&quot;); return mv; }} 1234. 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 1235. 编写前端test.jsp，注意在WEB-INF&#x2F;jsp目录下编写，对应我们的视图解析器 Kuangshen ${msg} 1234567891011121314151617181920216. 配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 &#x2F; ，所以请求不用加项目名，OK！ ![图片](640)**说明：**- 实现接口Controller定义控制器是较老的办法- 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； ### 使用注解@Controller- @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）；- Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 123- 增加一个ControllerTest2类，使用注解实现； //@Controller注解的类会自动添加到Spring上下文中 @Controller public class ControllerTest2{ //映射访问路径 @RequestMapping(“/t2”) public String index(Model model){ //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;ControllerTest2&quot;); //返回视图位置 return &quot;test&quot;; } } 1234567891011121314151617181920212223- 运行tomcat测试 ![图片](640) **可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。****注解方式是平时使用的最多的方式！**### RequestMapping**@RequestMapping**- @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。- 为了测试结论更加准确，我们可以加上一个项目名测试 myweb- 只注解在方法上面 @Controller public class TestController { @RequestMapping(“/h1”) public String test(){ return “test”; } } 12345 访问路径：http:&#x2F;&#x2F;localhost:8080 &#x2F; 项目名 &#x2F; h1- 同时注解类与方法 @Controller @RequestMapping(“/admin”) public class TestController { @RequestMapping(“/h1”) public String test(){ return “test”; } } 12345678910111213141516171819202122232425262728293031323334353637383940414243 访问路径：http:&#x2F;&#x2F;localhost:8080 &#x2F; 项目名&#x2F; admin &#x2F;h1 , 需要先指定类的路径再指定方法的路径；### RestFul 风格**概念**Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。**功能**资源：互联网所有的事物都可以被抽象为资源资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。分别对应 添加、 删除、修改、查询。**传统方式操作资源** ：通过不同的参数来实现不同的效果！方法单一，post 和 get​ http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;queryItem.action?id&#x3D;1 查询,GET​ http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;saveItem.action 新增,POST​ http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;updateItem.action 更新,POST​ http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;deleteItem.action?id&#x3D;1 删除,GET或POST**使用RESTful操作资源** ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！​ http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;1 查询,GET​ http:&#x2F;&#x2F;127.0.0.1&#x2F;item 新增,POST​ http:&#x2F;&#x2F;127.0.0.1&#x2F;item 更新,PUT​ http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;1 删除,DELETE**学习测试**1. 在新建一个类 RestFulController @Controller public class RestFulController { } 1232. 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 @Controller public class RestFulController { //映射访问路径 @RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;) public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123; int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result); //返回视图位置 return &quot;test&quot;; &#125; } 123456789101112131415161718193. 我们来测试请求查看下 ![图片](data:image&#x2F;gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg&#x3D;&#x3D;)4. 思考：使用路径变量的好处？5. - 使路径变得更加简洁； - 获得参数更加方便，框架会自动进行类型转换。 - 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是&#x2F;commit&#x2F;1&#x2F;a，则路径与方法不匹配，而不会是参数转换失败。 ![图片](data:image&#x2F;gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg&#x3D;&#x3D;)6. 我们来修改下对应的参数类型，再次测试 //映射访问路径 @RequestMapping(“/commit/{p1}/{p2}”) public String index(@PathVariable int p1, @PathVariable String p2, Model model){ String result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result); //返回视图位置 return &quot;test&quot;; } 1234567891011 ![图片](data:image&#x2F;gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg&#x3D;&#x3D;)**使用method属性指定请求类型**用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等我们来测试一下：- 增加一个方法 //映射访问路径,必须是POST请求 @RequestMapping(value = “/hello”,method = {RequestMethod.POST}) public String index2(Model model){ model.addAttribute(“msg”, “hello!”); return “test”; } 1234567- 我们使用浏览器地址栏进行访问默认是Get请求，会报错405： ![图片](640)- 如果将POST修改为GET则正常了； //映射访问路径,必须是Get请求 @RequestMapping(value = “/hello”,method = {RequestMethod.GET}) public String index2(Model model){ model.addAttribute(“msg”, “hello!”); return “test”; } 1234567891011 ![图片](data:image&#x2F;gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg&#x3D;&#x3D;)**小结：**Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。**所有的地址栏请求默认都会是 HTTP GET 类型的。**方法级别的注解变体有如下几个：组合注解@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping 12345678910111213141516171819202122232425262728293031@GetMapping 是一个组合注解，平时使用的会比较多！它所扮演的是 @RequestMapping(method &#x3D;RequestMethod.GET) 的一个快捷方式。### 扩展：小黄鸭调试法场景一：*我们都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题的经历，但是很多时候就在我们解释的过程中自己却想到了问题的解决方案，然后对方却一脸茫然。*场景二：你的同行跑来问你一个问题，但是当他自己把问题说完，或说到一半的时候就想出答案走了，留下一脸茫然的你。其实上面两种场景现象就是所谓的小黄鸭调试法（Rubber Duck Debuging），又称橡皮鸭调试法，它是我们软件工程中最常使用调试方法之一。![图片](640)此概念据说来自《程序员修炼之道》书中的一个故事，传说程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码，然后很快就将问题定位修复了。## 数据处理及跳转![图片](640)## 结果跳转方式### ModelAndView设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 .页面 : &#123;视图解析器前缀&#125; + viewName +&#123;视图解析器后缀&#125; 123对应的controller类 public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(“msg”,”ControllerTest1”); mv.setViewName(“test”); return mv; }} 12345678910111213### ServletAPI通过设置ServletAPI , 不需要视图解析器 .1、通过HttpServletResponse进行输出2、通过HttpServletResponse实现重定向3、通过HttpServletResponse实现转发 @Controllerpublic class ResultGo { @RequestMapping(“/result/t1”) public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException { rsp.getWriter().println(“Hello,Spring BY servlet API”); } @RequestMapping(“/result/t2”) public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException { rsp.sendRedirect(“/index.jsp”); } @RequestMapping(“/result/t3”) public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception { //转发 req.setAttribute(“msg”,”/result/t3”); req.getRequestDispatcher(“/WEB-INF/jsp/test.jsp”).forward(req,rsp); } } 123456789### SpringMVC**通过SpringMVC来实现转发和重定向 - 无需视图解析器；**测试前，需要将视图解析器注释掉 @Controllerpublic class ResultSpringMVC { @RequestMapping(“/rsm/t1”) public String test1(){ //转发 return “/index.jsp”; } @RequestMapping(“/rsm/t2”) public String test2(){ //转发二 return “forward:/index.jsp”; } @RequestMapping(“/rsm/t3”) public String test3(){ //重定向 return “redirect:/index.jsp”; }} 123456789**通过SpringMVC来实现转发和重定向 - 有视图解析器；**重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题.可以重定向到另外一个请求实现 . @Controllerpublic class ResultSpringMVC2 { @RequestMapping(“/rsm2/t1”) public String test1(){ //转发 return “test”; } @RequestMapping(“/rsm2/t2”) public String test2(){ //重定向 return “redirect:/index.jsp”; //return “redirect:hello.do”; //hello.do为另一个请求/ } } 12345678910111213## 数据处理### 处理提交数据**1、提交的域名称和处理方法的参数名一致**提交数据 : http:&#x2F;&#x2F;localhost:8080&#x2F;hello?name&#x3D;kuangshen处理方法 : @RequestMapping(“/hello”)public String hello(String name){ System.out.println(name); return “hello”;} 1234567891011后台输出 : kuangshen**2、提交的域名称和处理方法的参数名不一致**提交数据 : http:&#x2F;&#x2F;localhost:8080&#x2F;hello?username&#x3D;kuangshen处理方法 : //@RequestParam(“username”) : username提交的域的名称 .@RequestMapping(“/hello”)public String hello(@RequestParam(“username”) String name){ System.out.println(name); return “hello”;} 1234567891011后台输出 : kuangshen**3、提交的是一个对象**要求提交的表单域和对象的属性名一致 , 参数使用对象即可1、实体类 public class User { private int id; private String name; private int age; //构造 //get/set //tostring()} 123452、提交数据 : http:&#x2F;&#x2F;localhost:8080&#x2F;mvc04&#x2F;user?name&#x3D;kuangshen&amp;id&#x3D;1&amp;age&#x3D;153、处理方法 : @RequestMapping(“/user”)public String user(User user){ System.out.println(user); return “hello”;} 12345678910111213后台输出 : User &#123; id&#x3D;1, name&#x3D;&#39;kuangshen&#39;, age&#x3D;15 &#125;说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。### 数据显示到前端**第一种 : 通过ModelAndView**我们前面一直都是如此 . 就不过多解释 public class ControllerTest1 implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(“msg”,”ControllerTest1”); mv.setViewName(“test”); return mv; }} 1234567**第二种 : 通过ModelMap**ModelMap @RequestMapping(“/hello”)public String hello(@RequestParam(“username”) String name, ModelMap model){ //封装要显示到视图中的数据 //相当于req.setAttribute(“name”,name); model.addAttribute(“name”,name); System.out.println(name); return “hello”;} 1234567**第三种 : 通过Model**Model @RequestMapping(“/ct2/hello”)public String hello(@RequestParam(“username”) String name, Model model){ //封装要显示到视图中的数据 //相当于req.setAttribute(“name”,name); model.addAttribute(“msg”,name); System.out.println(name); return “test”;} 1234567### 对比就对于新手而言简单来说使用区别就是： Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 12345678910111213当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。**请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。**### 乱码问题测试步骤：1、我们可以在首页编写一个提交的表单 1232、后台编写对应的处理类 @Controller public class Encoding { @RequestMapping(\"/e/t\") public String test(Model model,String name){ model.addAttribute(\"msg\",name); //获取表单提交的值 return \"test\"; //跳转到test页面显示输入的值 } } 12345678910113、输入中文测试，发现乱码![图片](640)不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 .修改了xml文件需要重启服务器！ encoding org.springframework.web.filter.CharacterEncodingFilter encoding utf-8 encoding /* 1234567但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 .处理方法 :1、修改tomcat配置文件 ：设置编码！ 1232、自定义过滤器 package com.kuang.filter; import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Map; /** 解决get和post请求 全部乱码的过滤器 /public class GenericEncodingFilter implements Filter { @Override public void destroy() { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { //处理response的字符编码 HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;); // 转型为与协议相关对象 HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强 HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); } @Override public void init(FilterConfig filterConfig) throws ServletException { } } //自定义request对象，HttpServletRequest的包装类class MyRequest extends HttpServletRequestWrapper { private HttpServletRequest request; //是否编码的标记 private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰 public MyRequest(HttpServletRequest request) { super(request);// super必须写 this.request = request; } // 对需要增强方法 进行覆盖 @Override public Map getParameterMap() { // 先获得请求方式 String method = request.getMethod(); if (method.equalsIgnoreCase(“post”)) { // post请求 try { // 处理post乱码 request.setCharacterEncoding(“utf-8”); return request.getParameterMap(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } else if (method.equalsIgnoreCase(“get”)) { // get请求 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); if (!hasEncode) { // 确保get手动编码逻辑只运行一次 for (String parameterName : parameterMap.keySet()) { String[] values = parameterMap.get(parameterName); if (values != null) { for (int i = 0; i &lt; values.length; i++) { try { // 处理get乱码 values[i] = new String(values[i] .getBytes(“ISO-8859-1”), “utf-8”); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } } hasEncode = true; } return parameterMap; } return super.getParameterMap(); } //取一个值 @Override public String getParameter(String name) { Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) { return null; } return values[0]; // 取回参数的第一个值 } //取所有值 @Override public String[] getParameterValues(String name) { Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; }} 1234567891011121314151617181920212223242526272829303132333435363738这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！**然后在web.xml中配置这个过滤器即可！**乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！## 整合SSM框架![图片](640)整合SSM框架### 整合SSM&gt; 环境要求环境：- IDEA- MySQL 5.7.19- Tomcat 9- Maven 3.6 要求：- 需要熟练掌握MySQL数据库，Spring，JavaWeb及MyBatis知识，简单的前端知识；&gt; 数据库环境创建一个存放书籍数据的数据库表 CREATE DATABASE ssmbuild; USE ssmbuild; DROP TABLE IF EXISTS books; CREATE TABLE books (bookID INT(10) NOT NULL AUTO_INCREMENT COMMENT ‘书id’,bookName VARCHAR(100) NOT NULL COMMENT ‘书名’,bookCounts INT(11) NOT NULL COMMENT ‘数量’,detail VARCHAR(200) NOT NULL COMMENT ‘描述’,KEY bookID (bookID)) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO books(bookID,bookName,bookCounts,detail)VALUES(1,’Java’,1,’从入门到放弃’),(2,’MySQL’,10,’从删库到跑路’),(3,’Linux’,5,’从进门到进牢’); 123456789&gt; 基本环境搭建1、新建一Maven项目！ssmbuild ， 添加web的支持2、导入相关的pom依赖！ junit junit 4.12 mysql mysql-connector-java 5.1.47 com.mchange c3p0 0.9.5.2 javax.servlet servlet-api 2.5 javax.servlet.jsp jsp-api 2.2 javax.servlet jstl 1.2 org.mybatis mybatis 3.5.2 org.mybatis mybatis-spring 2.0.2 org.springframework spring-webmvc 5.1.9.RELEASE org.springframework spring-jdbc 5.1.9.RELEASE 1233、Maven资源过滤设置 src/main/java **/*.properties **/*.xml false src/main/resources **/*.properties **/*.xml false 123456789101112134、建立基本结构和配置框架！- com.kuang.pojo- com.kuang.dao- com.kuang.service- com.kuang.controller- mybatis-config.xml 123- applicationContext.xml 1234567&gt; Mybatis层编写1、数据库配置文件 **database.properties** jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&useUnicode=true&characterEncoding=utf8 jdbc.username=root jdbc.password=123456 123452、IDEA关联数据库3、编写MyBatis的核心配置文件 123454、编写数据库对应的实体类 com.kuang.pojo.Books使用lombok插件！ package com.kuang.pojo; import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor; @Data@AllArgsConstructor@NoArgsConstructorpublic class Books { private int bookID; private String bookName; private int bookCounts; private String detail; } 1235、编写Dao层的 Mapper接口！ package com.kuang.dao; import com.kuang.pojo.Books;import java.util.List; public interface BookMapper { //增加一个Book int addBook(Books book); //根据id删除一个Book int deleteBookById(int id); //更新Book int updateBook(Books books); //根据id查询,返回一个Book Books queryBookById(int id); //查询全部Book,返回list集合 List queryAllBook(); } 1236、编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包； insert into ssmbuild.books(bookName,bookCounts,detail) values (#{bookName}, #{bookCounts}, #{detail}) delete from ssmbuild.books where bookID=#{bookID} update ssmbuild.books set bookName = #{bookName},bookCounts = #{bookCounts},detail = #{detail} where bookID = #{bookID} select * from ssmbuild.books where bookID = #{bookID} SELECT * from ssmbuild.books 123457、编写Service层的接口和实现类接口： package com.kuang.service; import com.kuang.pojo.Books; import java.util.List; //BookService:底下需要去实现,调用dao层public interface BookService { //增加一个Book int addBook(Books book); //根据id删除一个Book int deleteBookById(int id); //更新Book int updateBook(Books books); //根据id查询,返回一个Book Books queryBookById(int id); //查询全部Book,返回list集合 List queryAllBook();} 123实现类： package com.kuang.service; import com.kuang.dao.BookMapper;import com.kuang.pojo.Books;import java.util.List; public class BookServiceImpl implements BookService { //调用dao层的操作，设置一个set接口，方便Spring管理 private BookMapper bookMapper; public void setBookMapper(BookMapper bookMapper) { this.bookMapper = bookMapper; } public int addBook(Books book) { return bookMapper.addBook(book); } public int deleteBookById(int id) { return bookMapper.deleteBookById(id); } public int updateBook(Books books) { return bookMapper.updateBook(books); } public Books queryBookById(int id) { return bookMapper.queryBookById(id); } public List queryAllBook() { return bookMapper.queryAllBook(); }} 1234567891011**OK，到此，底层需求操作编写完毕！**&gt; Spring层1、配置**Spring整合MyBatis**，我们这里数据源使用c3p0连接池；2、我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml &lt;context:property-placeholder location=”classpath:database.properties”/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt; 1233、**Spring整合service层** &lt;context:component-scan base-package=”com.kuang.service” /&gt; 123456789Spring层搞定！再次理解一下，Spring就是一个大杂烩，一个容器！对吧！&gt; SpringMVC层1、**web.xml** DispatcherServlet org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:applicationContext.xml 1 DispatcherServlet / encodingFilter org.springframework.web.filter.CharacterEncodingFilter encoding utf-8 encodingFilter /* 15 1232、**spring-mvc.xml** &lt;mvc:annotation-driven /&gt; mvc:default-servlet-handler/ &lt;context:component-scan base-package=”com.kuang.controller” /&gt; 1233、**Spring配置整合文件，applicationContext.xml** 12345**配置文件，暂时结束！Controller 和 视图层编写**1、BookController 类编写 ， 方法一：查询全部书籍 @Controller @RequestMapping(\"/book\") public class BookController { @Autowired @Qualifier(“BookServiceImpl”) private BookService bookService; @RequestMapping(“/allBook”) public String list(Model model) { List list = bookService.queryAllBook(); model.addAttribute(“list”, list); return “allBook”; }} 1232、编写首页 **index.jsp** &lt;%@ page language=”java” contentType=”text/html; charset=UTF-8” pageEncoding=”UTF-8” %&gt; 首页 a { text-decoration: none; color: black; font-size: 18px; } h3 { width: 180px; height: 38px; margin: 100px auto; text-align: center; line-height: 38px; background: deepskyblue; border-radius: 4px; } 点击进入列表页 1233、书籍列表页面 **allbook.jsp** 书籍列表 书籍列表 —— 显示所有书籍 新增 书籍编号 书籍名字 书籍数量 书籍详情 操作 &lt;tbody&gt; &lt;c:forEach var=&quot;book&quot; items=&quot;$&#123;requestScope.get(&#39;list&#39;)&#125;&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.getBookID()&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.getBookName()&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.getDetail()&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toUpdateBook?id=$&#123;book.getBookID()&#125;&quot;&gt;更改&lt;/a&gt; | &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/del/$&#123;book.getBookID()&#125;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; 1234、BookController 类编写 ， 方法二：添加书籍 @RequestMapping(\"/toAddBook\") public String toAddPaper() { return \"addBook\"; } @RequestMapping(“/addBook”)public String addPaper(Books books) { System.out.println(books); bookService.addBook(books); return “redirect:/book/allBook”;} 1235、添加书籍页面：**addBook.jsp** &lt;%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt; 新增书籍 新增书籍 书籍名称： 书籍数量： 书籍详情： 1236、BookController 类编写 ， 方法三：修改书籍 @RequestMapping(\"/toUpdateBook\") public String toUpdateBook(Model model, int id) { Books books = bookService.queryBookById(id); System.out.println(books); model.addAttribute(\"book\",books ); return \"updateBook\"; } @RequestMapping(“/updateBook”)public String updateBook(Model model, Books book) { System.out.println(book); bookService.updateBook(book); Books books = bookService.queryBookById(book.getBookID()); model.addAttribute(“books”, books); return “redirect:/book/allBook”;} 1237、修改书籍页面 **updateBook.jsp** &lt;%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt; 修改信息 修改信息 书籍名称： 书籍数量： 书籍详情： 1238、BookController 类编写 ， 方法四：删除书籍 @RequestMapping(\"/del/{bookId}\") public String deleteBook(@PathVariable(\"bookId\") int id) { bookService.deleteBookById(id); return \"redirect:/book/allBook\"; } 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758**配置Tomcat，进行运行！**到目前为止，这个SSM项目整合已经完全的OK了，可以直接运行进行测试！这个练习十分的重要，大家需要保证，不看任何东西，自己也可以完整的实现出来！**项目结构图** ![图片](640)![图片](640)&gt; 小结及展望这个是同学们的第一个SSM整合案例，一定要烂熟于心！SSM框架的重要程度是不言而喻的，学到这里，大家已经可以进行基本网站的单独开发。但是这只是增删改查的基本操作。可以说学到这里，大家才算是真正的步入了后台开发的门。也就是能找一个后台相关工作的底线。或许很多人，工作就做这些事情，但是对于个人的提高来说，还远远不够！我们后面还要学习一些 SpringMVC 的知识！- Ajax 和 Json- 文件上传和下载- 拦截器## Json交互处理![图片](640)Json&gt; 什么是JSON？- JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。- 采用完全独立于编程语言的**文本格式**来存储和表示数据。- 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。- 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：- 对象表示为键值对，数据由逗号分隔- 花括号保存对象- 方括号保存数组**JSON 键值对**是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键&#x2F;值对组合中的键名写在前面并用双引号 &quot;&quot; 包裹，使用冒号 : 分隔，然后紧接着值： {\"name\": \"QinJiang\"} {\"age\": \"3\"} {\"sex\": \"男\"} 12345很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。 var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的 var json = '{\"a\": \"Hello\", \"b\": \"World\"}'; //这是一个 JSON 字符串，本质是一个字符串 1234567**JSON 和 JavaScript 对象互转**要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： var obj = JSON.parse('{\"a\": \"Hello\", \"b\": \"World\"}'); //结果是 {a: 'Hello', b: 'World'} 123要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{\"a\": \"Hello\", \"b\": \"World\"}' 123456789**代码测试**1、新建一个module ，springmvc-05-json ， 添加web的支持2、在web目录下新建一个 json-1.html ， 编写测试内容 JSON_秦疆 //编写一个js的对象 var user = { name:\"秦疆\", age:3, sex:\"男\" }; //将js对象转换成json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转换为js对象 var user2 = JSON.parse(str); console.log(user2.age,user2.name,user2.sex); 1234567891011121314153、在IDEA中使用浏览器打开，查看控制台输出！![图片](640)&gt; Controller返回JSON数据Jackson应该是目前比较好的json解析工具了当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。我们这里使用Jackson，使用它需要导入它的jar包； com.fasterxml.jackson.core jackson-databind 2.9.8 12345配置SpringMVC需要的配置web.xml SpringMVC org.springframework.web.servlet.DispatcherServlet contextConfigLocation classpath:springmvc-servlet.xml 1 SpringMVC / encoding org.springframework.web.filter.CharacterEncodingFilter encoding utf-8 encoding / 123springmvc-servlet.xml &lt;context:component-scan base-package=”com.kuang.controller”/&gt; 123我们随便编写一个User的实体类，然后我们去编写我们的测试Controller； package com.kuang.pojo; import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor; //需要导入lombok@Data@AllArgsConstructor@NoArgsConstructorpublic class User { private String name; private int age; private String sex; } 12345这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法编写一个Controller； @Controllerpublic class UserController { @RequestMapping(“/json1”) @ResponseBody public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(“秦疆1号”, 3, “男”); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 12345678910111213配置Tomcat ， 启动测试一下！http:&#x2F;&#x2F;localhost:8080&#x2F;json1![图片](data:image&#x2F;gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg&#x3D;&#x3D;)发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型；通过@RequestMaping的produces属性来实现，修改下代码 //produces:指定响应体返回类型和编码@RequestMapping(value = “/json1”,produces = “application/json;charset=utf-8”) 12345678910111213141516171819再次测试， http:&#x2F;&#x2F;localhost:8080&#x2F;json1 ， 乱码问题OK！![图片](data:image&#x2F;gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg&#x3D;&#x3D;)【注意：使用json记得处理乱码问题】&gt; 代码优化**乱码统一解决**上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！ mvc:annotation-driven &lt;mvc:message-converters register-defaults=”true”&gt; 1234567**返回json字符串统一解决**在类上直接使用 **@RestController** ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ @RestControllerpublic class UserController { //produces:指定响应体返回类型和编码 @RequestMapping(value = “/json1”) public String json1() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(“秦疆1号”, 3, “男”); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; } } 123456789启动tomcat测试，结果都正常输出！&gt; 测试集合输出增加一个新的方法 @RequestMapping(“/json2”)public String json2() throws JsonProcessingException { //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user1 = new User(“秦疆1号”, 3, “男”); User user2 = new User(“秦疆2号”, 3, “男”); User user3 = new User(“秦疆3号”, 3, “男”); User user4 = new User(“秦疆4号”, 3, “男”); List list = new ArrayList(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str;} 123456789运行结果 : 十分完美，没有任何问题！![图片](data:image&#x2F;gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg&#x3D;&#x3D;)&gt; 输出时间对象增加一个新的方法 @RequestMapping(“/json3”)public String json3() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date Date date = new Date(); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(date); return str;} 123456789101112运行结果 :![图片](640)- 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！- Jackson 默认是会把时间转成timestamps形式**解决方案：取消timestamps形式 ， 自定义时间格式** @RequestMapping(“/json4”)public String json4() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”); //指定日期格式 mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str;} 1234567891011运行结果 : 成功的输出了时间！![图片](640)&gt; 抽取为工具类**如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下** package com.kuang.utils; import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature; import java.text.SimpleDateFormat; public class JsonUtils { public static String getJson(Object object) { return getJson(object,”yyyy-MM-dd HH:mm:ss”); } public static String getJson(Object object,String dateFormat) { ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try { return mapper.writeValueAsString(object); } catch (JsonProcessingException e) { e.printStackTrace(); } return null; }} 123我们使用工具类，代码就更加简洁了！ @RequestMapping(“/json5”)public String json5() throws JsonProcessingException { Date date = new Date(); String json = JsonUtils.getJson(date); return json;} 1234567891011大功告成！完美！&gt; FastJsonfastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。fastjson 的 pom依赖！ com.alibaba fastjson 1.2.60 123456789101112131415161718192021fastjson 三个主要的类：**JSONObject 代表 json 对象** - JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。- JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取&quot;键：值&quot;对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。**JSONArray 代表 json 对象数组**- 内部是有List接口中的方法来完成操作的。**JSON代表 JSONObject和JSONArray的转化**- JSON类源码分析与使用- 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。**代码测试，我们新建一个FastJsonDemo 类** package com.kuang.controller; import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.kuang.pojo.User; import java.util.ArrayList;import java.util.List; public class FastJsonDemo { public static void main(String[] args) { //创建一个对象 User user1 = new User(“秦疆1号”, 3, “男”); User user2 = new User(“秦疆2号”, 3, “男”); User user3 = new User(“秦疆3号”, 3, “男”); User user4 = new User(“秦疆4号”, 3, “男”); List list = new ArrayList(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;); String str1 = JSON.toJSONString(list); System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1); String str2 = JSON.toJSONString(user1); System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2); System.out.println(&quot;\\n****** JSON字符串 转 Java对象*******&quot;); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1); System.out.println(&quot;\\n****** Java对象 转 JSON对象 ******&quot;); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;)); System.out.println(&quot;\\n****** JSON对象 转 Java对象 ******&quot;); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user); }} 1234567891011121314151617181920212223242526272829303132333435363738这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！## Ajax研究![图片](640)Ajax研究&gt; 简介- **AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。**- AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。- **Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。**- 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。- Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。- 就和国内百度的搜索框一样!- 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。- 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。- 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。&gt; 伪造Ajax我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签1、新建一个module ：sspringmvc-06-ajax ， 导入web支持！2、编写一个 ajax-frame.html 使用 iframe 测试，感受下效果 kuangshen window.onload = function(){ var myDate = new Date(); document.getElementById('currentTime').innerText = myDate.getTime(); }; function LoadPage(){ var targetUrl = document.getElementById('url').value; console.log(targetUrl); document.getElementById(\"iframePosition\").src = targetUrl; } 请输入要加载的地址： 加载页面位置： 12345678910111213141516171819202122232425263、使用IDEA开浏览器测试一下！**利用AJAX可以做：**- 注册时，输入用户名自动检测用户是否已经存在。- 登陆时，提示用户名密码错误- 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。- ....等等&gt; jQuery.ajax纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。jQuery 提供多个与 AJAX 有关的方法。通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。jQuery 不是生产者，而是大自然搬运工。jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: \"application/x-www-form-urlencoded; charset=UTF-8\") async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 \"xml\": 将服务器端返回的内容转换成xml格式 \"text\": 将服务器端返回的内容转换成普通文本格式 \"html\": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 \"script\": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 \"json\": 将服务器端返回的内容转换成相应的JavaScript对象 \"jsonp\": JSONP 格式使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 12345**我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用**1、配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】 &lt;context:component-scan base-package=”com.kuang.controller”/&gt; &lt;mvc:default-servlet-handler /&gt; &lt;mvc:annotation-driven /&gt; 1232、编写一个AjaxController @Controller public class AjaxController { @RequestMapping(“/a1”) public void ajax1(String name , HttpServletResponse response) throws IOException { if (“admin”.equals(name)){ response.getWriter().print(“true”); }else{ response.getWriter().print(“false”); } } } 1233、导入jquery ， 可以使用在线的CDN ， 也可以下载导入 1234、编写index.jsp测试 &lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt; $Title$ function a1(){ $.post({ url:\"${pageContext.request.contextPath}/a1\", data:{'name':$(\"#txtName\").val()}, success:function (data,status) { alert(data); alert(status); } }); } &lt;%–onblur：失去焦点触发事件–%&gt;用户名: 1234567895、启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ **Springmvc实现**实体类user @Data @AllArgsConstructor @NoArgsConstructor public class User { private String name; private int age; private String sex; } 123我们来获取一个集合对象，展示到前端页面 @RequestMapping(“/a2”)public List ajax2(){ List list = new ArrayList(); list.add(new User(“秦疆1号”,3,”男”)); list.add(new User(“秦疆2号”,3,”男”)); list.add(new User(“秦疆3号”,3,”男”)); return list; //由于@RestController注解，将list转成json格式返回} 123前端页面 &lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt; Title 姓名 年龄 性别 $(function () { $(\"#btn\").click(function () { $.post(\"${pageContext.request.contextPath}/a2\",function (data) { console.log(data) var html=\"\"; for (var i = 0; i","categories":[],"tags":[]},{"title":"MyBatis笔记","slug":"MyBatis","date":"2021-04-26T15:09:28.358Z","updated":"2021-04-27T10:55:51.004Z","comments":true,"path":"2021/04/26/MyBatis/","link":"","permalink":"http://example.com/2021/04/26/MyBatis/","excerpt":"","text":"MyBatis 环境说明： jdk 8 + MySQL 5.7.19 maven-3.6.1 IDEA 学习前需要掌握： JDBC MySQL Java 基础 Maven Junit 什么是MyBatis MyBatis 是一款优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。 MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。 2013年11月迁移到Github . Mybatis官方文档 : http://www.mybatis.org/mybatis-3/zh/index.html GitHub : https://github.com/mybatis/mybatis-3 持久化 持久化是将程序数据在持久状态和瞬时状态间转换的机制。 即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。 JDBC就是一种持久化机制。文件IO也是一种持久化机制。 在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。 为什么需要持久化服务呢？那是由于内存本身的缺陷引起的 内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。 内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。 持久层 什么是持久层？ 完成持久化工作的代码块 . —-&gt; dao层 【DAO (Data Access Object) 数据访问对象】 大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种关系数据库来完成。 不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现. 与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】 为什么需要Mybatis Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 . 传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率 . MyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) –&gt;对象关系映射 所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！技术没有高低之分，只有使用这个技术的人有高低之别 MyBatis的优点 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。 提供xml标签，支持编写动态sql。 ……. 最重要的一点，使用的人多！公司需要！ MyBatis第一个程序 思路流程：搭建环境–&gt;导入Mybatis—&gt;编写代码—&gt;测试 代码演示 1、搭建实验数据库 1234567891011121314CREATE DATABASE `mybatis`;USE `mybatis`;DROP TABLE IF EXISTS `user`;CREATE TABLE `user` (`id` int(20) NOT NULL,`name` varchar(30) DEFAULT NULL,`pwd` varchar(30) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `user`(`id`,`name`,`pwd`) values (1,&#x27;狂神&#x27;,&#x27;123456&#x27;),(2,&#x27;张三&#x27;,&#x27;abcdef&#x27;),(3,&#x27;李四&#x27;,&#x27;987654&#x27;); 2、导入MyBatis相关 jar 包 GitHub上找 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt; 3、编写MyBatis核心配置文件 查看帮助文档 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/kuang/dao/userMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4、编写MyBatis工具类 查看帮助文档 123456789101112131415161718192021222324252627import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //获取SqlSession连接 public static SqlSession getSession()&#123; return sqlSessionFactory.openSession(); &#125;&#125; 5、创建实体类 1234567891011public class User &#123; private int id; //id private String name; //姓名 private String pwd; //密码 //构造,有参,无参 //set/get //toString() &#125; 6、编写Mapper接口类 123456import com.kuang.pojo.User;import java.util.List;public interface UserMapper &#123; List&lt;User&gt; selectUser();&#125; 7、编写Mapper.xml配置文件 namespace 十分重要，不能写错！ 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.dao.UserMapper&quot;&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 8、编写测试类 Junit 包测试 12345678910111213141516public class MyTest &#123; @Test public void selectUser() &#123; SqlSession session = MybatisUtils.getSession(); //方法一: //List&lt;User&gt; users = session.selectList(&quot;com.kuang.mapper.UserMapper.selectUser&quot;); //方法二: UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.selectUser(); for (User user: users)&#123; System.out.println(user); &#125; session.close(); &#125;&#125; 9、运行测试，成功的查询出来的我们的数据，ok！ 问题说明 可能出现问题说明：Maven静态资源过滤问题 123456789101112131415161718&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; CRUD操作及配置解析CRUD操作 namespace 将上面案例中的UserMapper接口改名为 UserDao； 将UserMapper.xml中的namespace改为为UserDao的路径 . 再次测试 结论：配置文件中namespace中的名称为对应Mapper接口或者Dao接口的完整包名,必须一致！ select select标签是mybatis中最常用的标签之一 select语句有很多属性可以详细配置每一条SQL语句 SQL语句返回值类型。【完整的类名或者别名】 传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】 命名空间中唯一的标识符 接口中的方法名与映射文件中的SQL语句ID 一一对应 id parameterType resultType 需求：根据id查询用户 1、在UserMapper中添加对应方法 123456public interface UserMapper &#123; //查询全部用户 List&lt;User&gt; selectUser(); //根据id查询用户 User selectUserById(int id);&#125; 2、在UserMapper.xml中添加Select语句 123&lt;select id=&quot;selectUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;select * from user where id = #&#123;id&#125;&lt;/select&gt; 3、测试类中测试 12345678@Testpublic void tsetSelectUserById() &#123; SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接 UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close();&#125; 课堂练习：根据 密码 和 名字 查询用户 思路一：直接在方法中传递参数 1、在接口方法的参数前加 @Param属性 2、Sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型 12345678//通过密码和名字查询用户User selectUserByNP(@Param(&quot;username&quot;) String username,@Param(&quot;pwd&quot;) String pwd);/* &lt;select id=&quot;selectUserByNP&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125; &lt;/select&gt;*/ 思路二：使用万能的Map 1、在接口方法中，参数直接传递Map； 1User selectUserByNP2(Map&lt;String,Object&gt; map); 2、编写sql语句的时候，需要传递参数类型，参数类型为map 123&lt;select id=&quot;selectUserByNP2&quot; parameterType=&quot;map&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;select * from user where name = #&#123;username&#125; and pwd = #&#123;pwd&#125;&lt;/select&gt; 3、在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！ 1234Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();map.put(&quot;username&quot;,&quot;小明&quot;);map.put(&quot;pwd&quot;,&quot;123456&quot;);User user = mapper.selectUserByNP2(map); 总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可 insert 我们一般使用insert标签进行插入操作，它的配置和select标签差不多！ 需求：给数据库增加一个用户 1、在UserMapper接口中添加对应的方法 12//添加一个用户int addUser(User user); 2、在UserMapper.xml中添加insert语句 123&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt; insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&lt;/insert&gt; 3、测试 12345678910@Testpublic void testAddUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(5,&quot;王五&quot;,&quot;zxcvbn&quot;); int i = mapper.addUser(user); System.out.println(i); session.commit(); //提交事务,重点!不写的话不会提交到数据库 session.close();&#125; 注意点：增、删、改操作需要提交事务！ **** update 我们一般使用update标签进行更新操作，它的配置和select标签差不多！ 需求：修改用户的信息 1、同理，编写接口方法 12//修改一个用户int updateUser(User user); 2、编写对应的配置文件SQL 123&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt; update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;&lt;/update&gt; 3、测试 1234567891011@Testpublic void testUpdateUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); user.setPwd(&quot;asdfgh&quot;); int i = mapper.updateUser(user); System.out.println(i); session.commit(); //提交事务,重点!不写的话不会提交到数据库 session.close();&#125; delete 我们一般使用delete标签进行删除操作，它的配置和select标签差不多！ 需求：根据id删除一个用户 1、同理，编写接口方法 12//根据id删除用户int deleteUser(int id); 2、编写对应的配置文件SQL 123&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id = #&#123;id&#125;&lt;/delete&gt; 3、测试 123456789@Testpublic void testDeleteUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); int i = mapper.deleteUser(5); System.out.println(i); session.commit(); //提交事务,重点!不写的话不会提交到数据库 session.close();&#125; 小结： 所有的增删改操作都需要提交事务！ 接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！ 有时候根据业务的需求，可以考虑使用map传递参数！ 为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！ 思考题 模糊查询like语句该怎么写? 第1种：在Java代码中添加sql通配符。 123456string wildcardname = “%smi%”;list&lt;name&gt; names = mapper.selectlike(wildcardname);&lt;select id=”selectlike”&gt;select * from foo where bar like #&#123;value&#125;&lt;/select&gt; 第2种：在sql语句中拼接通配符，会引起sql注入 123456string wildcardname = “smi”;list&lt;name&gt; names = mapper.selectlike(wildcardname);&lt;select id=”selectlike”&gt; select * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;&lt;/select&gt; 配置解析 核心配置文件 mybatis-config.xml 系统核心配置文件 MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 能配置的内容如下： 1234567891011121314configuration（配置）properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器）&lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt; 我们可以阅读 mybatis-config.xml 上面的dtd的头文件！ environments元素 12345678910111213&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定） 子元素节点：environment dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。 数据源是必须配置的。 有三种内建的数据源类型 1type=&quot;[UNPOOLED|POOLED|JNDI]&quot;） unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。 pooled：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等…. 详情：点击查看官方文档 这两种事务管理器类型都不需要设置任何属性。 具体的一套环境，通过设置id进行区别，id保证唯一！ 子元素节点：transactionManager - [ 事务管理器 ] 12&lt;!-- 语法 --&gt;&lt;transactionManager type=&quot;[ JDBC | MANAGED ]&quot;/&gt; 子元素节点：数据源（dataSource） mappers元素 mappers 映射器 : 定义映射SQL语句文件 既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。 引入资源方式 12345678910111213141516171819202122&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;&lt;/mappers&gt;&lt;!--使用映射器接口实现类的完全限定类名需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt; &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;&lt;/mappers&gt;&lt;!--将包内的映射器接口实现全部注册为映射器但是需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt; &lt;package name=&quot;org.mybatis.builder&quot;/&gt;&lt;/mappers&gt; Mapper文件 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.mapper.UserMapper&quot;&gt; &lt;/mapper&gt; namespace中文意思：命名空间，作用如下： namespace的命名必须跟某个接口同名 接口中的方法与映射文件中sql语句id应该一一对应 namespace和子元素的id联合保证唯一 , 区别不同的mapper 绑定DAO接口 namespace命名规则 : 包名+类名 MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。 Properties优化 数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。具体的官方文档 我们来优化我们的配置文件 第一步 ; 在资源目录下新建一个db.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8username=rootpassword=123456 第二步 : 将文件导入properties 配置文件 12345678910111213141516171819&lt;configuration&gt; &lt;!--导入properties文件--&gt; &lt;properties resource=&quot;db.properties&quot;/&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 更多操作，可以查看官方文档！【演示带领学习】 配置文件优先级问题 新特性：使用占位符 typeAliases优化 类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。 1234&lt;!--配置别名,注意顺序--&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.kuang.pojo.User&quot; alias=&quot;User&quot;/&gt;&lt;/typeAliases&gt; 当这样配置时，User可以用在任何使用com.kuang.pojo.User的地方。 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如: 123&lt;typeAliases&gt; &lt;package name=&quot;com.kuang.pojo&quot;/&gt;&lt;/typeAliases&gt; 每一个在包 com.kuang.pojo 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 若有注解，则别名为其注解值。见下面的例子： 1234@Alias(&quot;user&quot;)public class User &#123; ...&#125; 去官网查看一下Mybatis默认的一些类型别名！ 其他配置浏览 设置 设置（settings）相关 =&gt; 查看帮助文档 懒加载 日志实现 缓存开启关闭 一个配置完整的 settings 元素的示例如下： 1234567891011121314151617&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt; &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt; &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt; &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt; &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt; &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;&lt;/settings&gt; 类型处理器 无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】 对象工厂 MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。 如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】 生命周期和作用域 作用域（Scope）和生命周期 理解我们目前已经讨论过的不同作用域和生命周期类是至关重要的，因为错误的使用会导致非常严重的并发问题。 我们可以先画一个流程图，分析一下Mybatis的执行过程！ 作用域理解 SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后，SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中，而不要让其长期存在。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。 由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。 因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以说 SqlSessionFactory 的最佳作用域是应用作用域。 如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接（Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback 等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try…catch…finally… 语句来保证其正确关闭。 所以 SqlSession 的最佳的作用域是请求或方法作用域。 ResultMap及分页ResultMap 查询为null问题 要解决的问题：属性名和字段名不一致 环境：新建一个项目，将之前的项目拷贝过来 1、查看之前的数据库的字段名 2、Java中的实体类设计 12345678910public class User &#123; private int id; //id private String name; //姓名 private String password; //密码和数据库不一样！ //构造 //set/get //toString()&#125; 3、接口 12//根据id查询用户User selectUserById(int id); 4、mapper映射文件 123&lt;select id=&quot;selectUserById&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;id&#125;&lt;/select&gt; 5、测试 12345678@Testpublic void testSelectUserById() &#123; SqlSession session = MybatisUtils.getSession(); //获取SqlSession连接 UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close();&#125; 结果: User{id=1, name=’狂神’, password=’null’} 查询出来发现 password 为空 . 说明出现了问题！ 分析： select * from user where id = #{id} 可以看做 select id,name,pwd from user where id = #{id} mybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找相应列名的set方法设值 , 由于找不到setPwd() , 所以password返回null ; 【自动映射】 解决方案 方案一：为列名指定别名 , 别名和java实体类的属性名一致 . 123&lt;select id=&quot;selectUserById&quot; resultType=&quot;User&quot;&gt; select id , name , pwd as password from user where id = #&#123;id&#125;&lt;/select&gt; 方案二：使用结果集映射-&gt;ResultMap 【推荐】 1234567891011&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!-- id为主键 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt; select id , name , pwd from user where id = #&#123;id&#125;&lt;/select&gt; ResultMap 自动映射 resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来。 实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 resultMap 能够代替实现同等功能的长达数千行的代码。 ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。 你已经见过简单映射语句的示例了，但并没有显式指定 resultMap。比如： 12345&lt;select id=&quot;selectUserById&quot; resultType=&quot;map&quot;&gt;select id , name , pwd from user where id = #&#123;id&#125;&lt;/select&gt; 上述语句只是简单地将所有的列映射到 HashMap 的键上，这由 resultType 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。 ResultMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。 手动映射 1、返回值类型为resultMap 123&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt; select id , name , pwd from user where id = #&#123;id&#125;&lt;/select&gt; 2、编写resultMap，实现手动映射！ 1234567&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!-- id为主键 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt; 如果世界总是这么简单就好了。但是肯定不是的，数据库中，存在一对多，多对一的情况，我们之后会使用到一些高级的结果集映射，association，collection这些，我们将在之后讲解，今天你们需要把这些知识都消化掉才是最重要的！理解结果集映射的这个概念！ 分页的几种方式 日志工厂 思考：我们在测试SQL的时候，要是能够在控制台输出 SQL 的话，是不是就能够有更快的排错效率？ 如果一个 数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。 对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具。 Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具： SLF4J Apache Commons Logging Log4j 2 Log4j JDK logging 具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。 标准日志实现 指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; 测试，可以看到控制台有大量的输出！我们可以通过这些输出来判断程序到底哪里出了Bug Log4j 简介： Log4j是Apache的一个开源项目 通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件…. 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 使用步骤： 1、导入log4j的包 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 2、配置文件编写 123456789101112131415161718192021222324#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/kuang.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 3、setting设置日志实现 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt; 4、在程序中使用Log4j进行输出！ 12345678910111213141516//注意导包：org.apache.log4j.Loggerstatic Logger logger = Logger.getLogger(MyTest.class);@Testpublic void selectUser() &#123; logger.info(&quot;info：进入selectUser方法&quot;); logger.debug(&quot;debug：进入selectUser方法&quot;); logger.error(&quot;error: 进入selectUser方法&quot;); SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.selectUser(); for (User user: users)&#123; System.out.println(user); &#125; session.close();&#125; 5、测试，看控制台输出！ 使用Log4j 输出日志 可以看到还生成了一个日志的文件 【需要修改file的日志级别】 limit实现分页 思考：为什么需要分页？ 在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查询操作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内。 使用Limit实现分页 123456789101112#语法SELECT * FROM table LIMIT stratIndex，pageSizeSELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 #为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. #如果只给定一个参数，它表示返回最大的记录行数目： SELECT * FROM table LIMIT 5; //检索前 5 个记录行 #换句话说，LIMIT n 等价于 LIMIT 0,n。 步骤： 1、修改Mapper文件 123&lt;select id=&quot;selectUser&quot; parameterType=&quot;map&quot; resultType=&quot;user&quot;&gt; select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;/select&gt; 2、Mapper接口，参数为map 12//选择全部用户实现分页List&lt;User&gt; selectUser(Map&lt;String,Integer&gt; map); 3、在测试类中传入参数测试 推断：起始位置 = （当前页面 - 1 ） * 页面大小 1234567891011121314151617181920//分页查询 , 两个参数startIndex , pageSize@Testpublic void testSelectUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); int currentPage = 1; //第几页 int pageSize = 2; //每页显示几个 Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put(&quot;startIndex&quot;,(currentPage-1)*pageSize); map.put(&quot;pageSize&quot;,pageSize); List&lt;User&gt; users = mapper.selectUser(map); for (User user: users)&#123; System.out.println(user); &#125; session.close();&#125; RowBounds分页 我们除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，当然此种方式作为了解即可。我们来看下如何实现的！ 步骤： 1、mapper接口 12//选择全部用户RowBounds实现分页List&lt;User&gt; getUserByRowBounds(); 2、mapper文件 123&lt;select id=&quot;getUserByRowBounds&quot; resultType=&quot;user&quot;&gt;select * from user&lt;/select&gt; 3、测试类 在这里，我们需要使用RowBounds类 12345678910111213141516@Testpublic void testUserByRowBounds() &#123; SqlSession session = MybatisUtils.getSession(); int currentPage = 2; //第几页 int pageSize = 2; //每页显示几个 RowBounds rowBounds = new RowBounds((currentPage-1)*pageSize,pageSize); //通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了] List&lt;User&gt; users = session.selectList(&quot;com.kuang.mapper.UserMapper.getUserByRowBounds&quot;, null, rowBounds); for (User user: users)&#123; System.out.println(user); &#125; session.close();&#125; PageHelper 官方文档：https://pagehelper.github.io/ 在MyBatisPlus中，我们也讲解到了分页实现，所以实现方式很多，看自己的理解和熟练程度进行掌握即可！ 使用注解开发使用注解开发 面向接口编程 大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 根本原因 : 解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了； 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。 关于接口的理解 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。 接口的本身反映了系统设计人员对系统的抽象理解。 接口应有两类： 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）； 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。 三个面向区别 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 . 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 . 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构 利用注解开发 mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建 sql 类型主要分成 : @select () @update () @Insert () @delete () 注意：利用注解开发就不需要mapper.xml映射文件了 . 1、我们在我们的接口中添加注解 123//查询全部用户@Select(&quot;select id,name,pwd password from user&quot;)public List&lt;User&gt; getAllUser(); 2、在mybatis的核心配置文件中注入 1234&lt;!--使用class绑定接口--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.kuang.mapper.UserMapper&quot;/&gt;&lt;/mappers&gt; 3、我们去进行测试 12345678910111213@Testpublic void testGetAllUser() &#123; SqlSession session = MybatisUtils.getSession(); //本质上利用了jvm的动态代理机制 UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.getAllUser(); for (User user : users)&#123; System.out.println(user); &#125; session.close();&#125; 4、利用Debug查看本质 5、本质上利用了jvm的动态代理机制 6、Mybatis详细的执行流程 注解增删改 改造MybatisUtils工具类的getSession( ) 方法，重载实现。 12345678//获取SqlSession连接public static SqlSession getSession()&#123; return getSession(true); //事务自动提交&#125; public static SqlSession getSession(boolean flag)&#123; return sqlSessionFactory.openSession(flag);&#125; 【注意】确保实体类和数据库字段对应 查询： 1、编写接口方法注解 123//根据id查询用户@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)User selectUserById(@Param(&quot;id&quot;) int id); 2、测试 12345678910@Testpublic void testSelectUserById() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close();&#125; 新增： 1、编写接口方法注解 123//添加一个用户@Insert(&quot;insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&quot;)int addUser(User user); 2、测试 12345678910@Testpublic void testAddUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(6, &quot;秦疆&quot;, &quot;123456&quot;); mapper.addUser(user); session.close();&#125; 修改： 1、编写接口方法注解 123//修改一个用户@Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;&quot;)int updateUser(User user); 2、测试 12345678910@Testpublic void testUpdateUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(6, &quot;秦疆&quot;, &quot;zxcvbn&quot;); mapper.updateUser(user); session.close();&#125; 删除： 1、编写接口方法注解 123//根据id删除用@Delete(&quot;delete from user where id = #&#123;id&#125;&quot;)int deleteUser(@Param(&quot;id&quot;)int id); 2、测试 123456789@Testpublic void testDeleteUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); mapper.deleteUser(6); session.close();&#125; 【注意点：增删改一定记得对事务的处理】 关于@Param @Param注解用于给方法参数起一个名字。以下是总结的使用原则： 在方法只接受一个参数的情况下，可以不使用@Param。 在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。 如果参数是 JavaBean ， 则不能使用@Param。 不使用@Param注解时，参数只能有一个，并且是Javabean。 #与$的区别 #{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】 12INSERT INTO user (name) VALUES (#&#123;name&#125;);INSERT INTO user (name) VALUES (?); ${} 的作用是直接进行字符串替换 12INSERT INTO user (name) VALUES (&#39;$&#123;name&#125;&#39;);INSERT INTO user (name) VALUES (&#39;kuangshen&#39;); 使用注解和配置文件协同开发，才是MyBatis的最佳实践！ 一对多和多对一处理多对一处理多对一的理解： 多个学生对应一个老师 如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！ 数据库设计 1234567891011121314151617181920212223CREATE TABLE `teacher` (`id` INT(10) NOT NULL,`name` VARCHAR(30) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO teacher(`id`, `name`) VALUES (1, &#x27;秦老师&#x27;);CREATE TABLE `student` (`id` INT(10) NOT NULL,`name` VARCHAR(30) DEFAULT NULL,`tid` INT(10) DEFAULT NULL,PRIMARY KEY (`id`),KEY `fktid` (`tid`),CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;1&#x27;, &#x27;小明&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;2&#x27;, &#x27;小红&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;3&#x27;, &#x27;小张&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;4&#x27;, &#x27;小李&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;5&#x27;, &#x27;小王&#x27;, &#x27;1&#x27;); 搭建测试环境 1、IDEA安装Lombok插件 2、引入Maven依赖 123456&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt;&lt;/dependency&gt; 3、在代码中增加注解 123456789101112@Data //GET,SET,ToString，有参，无参构造public class Teacher &#123; private int id; private String name;&#125;@Datapublic class Student &#123; private int id; private String name; //多个学生可以是同一个老师，即多对一 private Teacher teacher;&#125; 4、编写实体类对应的Mapper接口 【两个】 无论有没有需求，都应该写上，以备后来之需！ 1234public interface StudentMapper &#123;&#125;public interface TeacherMapper &#123;&#125; 5、编写Mapper接口对应的 mapper.xml配置文件 【两个】 无论有没有需求，都应该写上，以备后来之需！ 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.mapper.StudentMapper&quot;&gt;&lt;/mapper&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.mapper.TeacherMapper&quot;&gt;&lt;/mapper&gt; 按查询嵌套处理 1、给StudentMapper接口增加方法 12//获取所有学生及对应老师的信息public List&lt;Student&gt; getStudents(); 2、编写对应的Mapper文件 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.mapper.StudentMapper&quot;&gt; &lt;!-- 需求：获取所有学生及对应老师的信息 思路： 1. 获取所有学生的信息 2. 根据获取的学生信息的老师ID-&gt;获取该老师的信息 3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？ 1. 做一个结果集映射：StudentTeacher 2. StudentTeacher结果集的类型为 Student 3. 学生中老师的属性为teacher，对应数据库中为tid。 多个 [1,...）学生关联一个老师=&gt; 一对一，一对多 4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询 --&gt; &lt;select id=&quot;getStudents&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student &lt;/select&gt; &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt; &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt; &lt;/resultMap&gt; &lt;!-- 这里传递过来的id，只有一个属性的时候，下面可以写任何值 association中column多参数配置： column=&quot;&#123;key=value,key=value&#125;&quot; 其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。 --&gt; &lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt; select * from teacher where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 3、编写完毕去Mybatis配置文件中，注册Mapper！ 4、注意点说明： 12345678910111213&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt; &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt; &lt;association property=&quot;teacher&quot; column=&quot;&#123;id=tid,name=tid&#125;&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;!--这里传递过来的id，只有一个属性的时候，下面可以写任何值association中column多参数配置： column=&quot;&#123;key=value,key=value&#125;&quot; 其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。--&gt;&lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt; select * from teacher where id = #&#123;id&#125; and name = #&#123;name&#125;&lt;/select&gt; 5、测试 12345678910111213@Testpublic void testGetStudents()&#123; SqlSession session = MybatisUtils.getSession(); StudentMapper mapper = session.getMapper(StudentMapper.class); List&lt;Student&gt; students = mapper.getStudents(); for (Student student : students)&#123; System.out.println( &quot;学生名:&quot;+ student.getName() +&quot;\\t老师:&quot;+student.getTeacher().getName()); &#125;&#125; 按结果嵌套处理 除了上面这种方式，还有其他思路吗？ 我们还可以按照结果进行嵌套处理； 1、接口方法编写 1public List&lt;Student&gt; getStudents2(); 2、编写对应的mapper文件 12345678910111213141516171819&lt;!--按查询结果嵌套处理思路： 1. 直接查询出结果，进行结果集的映射--&gt;&lt;select id=&quot;getStudents2&quot; resultMap=&quot;StudentTeacher2&quot; &gt; select s.id sid, s.name sname , t.name tname from student s,teacher t where s.tid = t.id&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;!--关联对象property 关联对象在Student实体类中的属性--&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 3、去mybatis-config文件中注入【此处应该处理过了】 4、测试 12345678910111213@Testpublic void testGetStudents2()&#123; SqlSession session = MybatisUtils.getSession(); StudentMapper mapper = session.getMapper(StudentMapper.class); List&lt;Student&gt; students = mapper.getStudents2(); for (Student student : students)&#123; System.out.println( &quot;学生名:&quot;+ student.getName() +&quot;\\t老师:&quot;+student.getTeacher().getName()); &#125;&#125; 小结 按照查询进行嵌套处理就像SQL中的子查询 按照结果进行嵌套处理就像SQL中的联表查询 一对多处理 一对多的处理一对多的理解： 一个老师拥有多个学生 如果对于老师这边，就是一个一对多的现象，即从一个老师下面拥有一群学生（集合）！ 实体类编写 12345678910111213@Datapublic class Student &#123; private int id; private String name; private int tid;&#125;@Datapublic class Teacher &#123; private int id; private String name; //一个老师多个学生 private List&lt;Student&gt; students;&#125; ….. 和之前一样，搭建测试的环境！ 按结果嵌套处理 1、TeacherMapper接口编写方法 12//获取指定老师，及老师下的所有学生public Teacher getTeacher(int id); 2、编写接口对应的Mapper配置文件 1234567891011121314151617181920212223242526&lt;mapper namespace=&quot;com.kuang.mapper.TeacherMapper&quot;&gt; &lt;!-- 思路: 1. 从学生表和老师表中查出学生id，学生姓名，老师姓名 2. 对查询出来的操作做结果集映射 1. 集合的话，使用collection！ JavaType和ofType都是用来指定对象类型的 JavaType是用来指定pojo中属性的类型 ofType指定的是映射到list集合属性中pojo的类型。 --&gt; &lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt; select s.id sid, s.name sname , t.name tname, t.id tid from student s,teacher t where s.tid = t.id and t.id=#&#123;id&#125; &lt;/select&gt; &lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot; /&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot; /&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 3、将Mapper文件注册到MyBatis-config文件中 123&lt;mappers&gt; &lt;mapper resource=&quot;mapper/TeacherMapper.xml&quot;/&gt;&lt;/mappers&gt; 4、测试 12345678@Testpublic void testGetTeacher()&#123; SqlSession session = MybatisUtils.getSession(); TeacherMapper mapper = session.getMapper(TeacherMapper.class); Teacher teacher = mapper.getTeacher(1); System.out.println(teacher.getName()); System.out.println(teacher.getStudents());&#125; 按查询嵌套处理 1、TeacherMapper接口编写方法 1public Teacher getTeacher2(int id); 2、编写接口对应的Mapper配置文件 12345678910&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt;select * from teacher where id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;Teacher&quot;&gt; &lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt; &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; column=&quot;id&quot; select=&quot;getStudentByTeacherId&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt; select * from student where tid = #&#123;id&#125;&lt;/select&gt; 3、将Mapper文件注册到MyBatis-config文件中 4、测试 12345678@Testpublic void testGetTeacher2()&#123; SqlSession session = MybatisUtils.getSession(); TeacherMapper mapper = session.getMapper(TeacherMapper.class); Teacher teacher = mapper.getTeacher2(1); System.out.println(teacher.getName()); System.out.println(teacher.getStudents());&#125; 小结 1、关联-association 2、集合-collection 3、所以association是用于一对一和多对一，而collection是用于一对多的关系 4、JavaType和ofType都是用来指定对象类型的 JavaType是用来指定pojo中属性的类型 ofType指定的是映射到list集合属性中pojo的类型。 注意说明： 1、保证SQL的可读性，尽量通俗易懂 2、根据实际要求，尽量编写性能更高的SQL语句 3、注意属性名和字段不一致的问题 4、注意一对多和多对一 中：字段和属性对应的问题 5、尽量使用Log4j，通过日志来查看自己的错误 动态SQL动态SQL 介绍 什么是动态SQL：动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句. 1234567891011官网描述：MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。 ------------------------------- - if - choose (when, otherwise) - trim (where, set) - foreach ------------------------------- 我们之前写的 SQL 语句都比较简单，如果有比较复杂的业务，我们需要写复杂的 SQL 语句，往往需要拼接，而拼接 SQL ，稍微不注意，由于引号，空格等缺失可能都会导致错误。 那么怎么去解决这个问题呢？这就要使用 mybatis 动态SQL，通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了开发人员的效率。 搭建环境 新建一个数据库表：blog 字段：id，title，author，create_time，views 1234567CREATE TABLE `blog` (`id` varchar(50) NOT NULL COMMENT &#x27;博客id&#x27;,`title` varchar(100) NOT NULL COMMENT &#x27;博客标题&#x27;,`author` varchar(30) NOT NULL COMMENT &#x27;博客作者&#x27;,`create_time` datetime NOT NULL COMMENT &#x27;创建时间&#x27;,`views` int(30) NOT NULL COMMENT &#x27;浏览量&#x27;) ENGINE=InnoDB DEFAULT CHARSET=utf8 1、创建Mybatis基础工程 2、IDutil工具类 1234567public class IDUtil &#123; public static String genId()&#123; return UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); &#125;&#125; 3、实体类编写 【注意set方法作用】 1234567891011import java.util.Date;public class Blog &#123; private String id; private String title; private String author; private Date createTime; private int views; //set，get....&#125; 4、编写Mapper接口及xml文件 123456789public interface BlogMapper &#123;&#125;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.mapper.BlogMapper&quot;&gt;&lt;/mapper&gt; 5、mybatis核心配置文件，下划线驼峰自动转换 12345678&lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt;&lt;!--注册Mapper.xml--&gt;&lt;mappers&gt; &lt;mapper resource=&quot;mapper/BlogMapper.xml&quot;/&gt;&lt;/mappers&gt; 6、插入初始数据 编写接口 12//新增一个博客int addBlog(Blog blog); sql配置文件 1234&lt;insert id=&quot;addBlog&quot; parameterType=&quot;blog&quot;&gt; insert into blog (id, title, author, create_time, views) values (#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;);&lt;/insert&gt; 初始化博客方法 12345678910111213141516171819202122232425262728@Testpublic void addInitBlog()&#123; SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(IDUtil.genId()); blog.setTitle(&quot;Mybatis如此简单&quot;); blog.setAuthor(&quot;狂神说&quot;); blog.setCreateTime(new Date()); blog.setViews(9999); mapper.addBlog(blog); blog.setId(IDUtil.genId()); blog.setTitle(&quot;Java如此简单&quot;); mapper.addBlog(blog); blog.setId(IDUtil.genId()); blog.setTitle(&quot;Spring如此简单&quot;); mapper.addBlog(blog); blog.setId(IDUtil.genId()); blog.setTitle(&quot;微服务如此简单&quot;); mapper.addBlog(blog); session.close();&#125; 初始化数据完毕！ if 语句 需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询 1、编写接口类 12//需求1List&lt;Blog&gt; queryBlogIf(Map map); 2、编写SQL语句 1234567891011121314&lt;!--需求1：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询select * from blog where title = #&#123;title&#125; and author = #&#123;author&#125;--&gt;&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog where &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/select&gt; 3、测试 1234567891011121314@Testpublic void testQueryBlogIf()&#123; SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;title&quot;,&quot;Mybatis如此简单&quot;); map.put(&quot;author&quot;,&quot;狂神说&quot;); List&lt;Blog&gt; blogs = mapper.queryBlogIf(map); System.out.println(blogs); session.close();&#125; 这样写我们可以看到，如果 author 等于 null，那么查询语句为 select * from user where title=#{title},但是如果title为空呢？那么查询语句为 select * from user where and author=#{author}，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句！ Where 修改上面的SQL语句； 1234567891011&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。 Set 同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们怎么处理呢？ 1、编写接口方法 1int updateBlog(Map map); 2、sql配置文件 12345678910111213&lt;!--注意set是用的逗号隔开--&gt;&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt; update blog &lt;set&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; author = #&#123;author&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;;&lt;/update&gt; 3、测试 123456789101112131415@Testpublic void testUpdateBlog()&#123; SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;title&quot;,&quot;动态SQL&quot;); map.put(&quot;author&quot;,&quot;秦疆&quot;); map.put(&quot;id&quot;,&quot;9d6a763f5e1347cebda43e2a32687a77&quot;); mapper.updateBlog(map); session.close();&#125; choose语句 有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句 1、编写接口方法 1List&lt;Blog&gt; queryBlogChoose(Map map); 2、sql配置文件 12345678910111213141516&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and views = #&#123;views&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 3、测试类 123456789101112131415@Testpublic void testQueryBlogChoose()&#123; SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;title&quot;,&quot;Java如此简单&quot;); map.put(&quot;author&quot;,&quot;狂神说&quot;); map.put(&quot;views&quot;,9999); List&lt;Blog&gt; blogs = mapper.queryBlogChoose(map); System.out.println(blogs); session.close();&#125; SQL片段 有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。 提取SQL片段： 12345678&lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/sql&gt; 引用SQL片段： 12345678&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt; &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt; &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt; &lt;/where&gt;&lt;/select&gt; 注意： ①、最好基于 单表来定义 sql 片段，提高片段的可重用性 ②、在 sql 片段中不要包括 where Foreach 将数据库中前三个数据的id修改为1,2,3； 需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息 1、编写接口 1List&lt;Blog&gt; queryBlogForeach(Map map); 2、编写SQL语句 12345678910111213141516&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from blog &lt;where&gt; &lt;!-- collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串 select * from blog where 1=1 and (id=1 or id=2 or id=3) --&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; id=#&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 3、测试 123456789101112131415161718@Testpublic void testQueryBlogForeach()&#123; SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); HashMap map = new HashMap(); List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(1); ids.add(2); ids.add(3); map.put(&quot;ids&quot;,ids); List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map); System.out.println(blogs); session.close();&#125; 小结：其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧。 缓存缓存 简介 1、什么是缓存 [ Cache ]？ 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。 2、为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率。 3、什么样的数据能使用缓存？ 经常查询并且不经常改变的数据。 Mybatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。 MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 一级缓存 一级缓存也叫本地缓存： 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库； 测试 1、在mybatis中加入日志，方便测试结果 2、编写接口方法 12//根据id查询用户User queryUserById(@Param(&quot;id&quot;) int id); 3、接口对应的Mapper文件 123&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;id&#125;&lt;/select&gt; 4、测试 12345678910111213@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 5、结果分析 一级缓存失效的四种情况 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它； 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！ 1、sqlSession不同 12345678910111213141516@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close(); session2.close();&#125; 观察结果：发现发送了两条SQL语句！ 结论：每个sqlSession中的缓存相互独立 2、sqlSession相同，查询条件不同 1234567891011121314@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper2.queryUserById(2); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 观察结果：发现发送了两条SQL语句！很正常的理解 结论：当前缓存中，不存在这个数据 3、sqlSession相同，两次查询之间执行了增删改操作！ 增加方法 12//修改用户int updateUser(Map map); 编写SQL 123&lt;update id=&quot;updateUser&quot; parameterType=&quot;map&quot;&gt; update user set name = #&#123;name&#125; where id = #&#123;id&#125;&lt;/update&gt; 测试 1234567891011121314151617181920@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); HashMap map = new HashMap(); map.put(&quot;name&quot;,&quot;kuangshen&quot;); map.put(&quot;id&quot;,4); mapper.updateUser(map); User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 观察结果：查询在中间执行了增删改操作后，重新执行了 结论：因为增删改操作可能会对当前数据产生影响 4、sqlSession相同，手动清除一级缓存 1234567891011121314151617@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); session.clearCache();//手动清除缓存 User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 一级缓存就是一个map 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存； 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 使用步骤 1、开启全局缓存 【mybatis-config.xml】 1&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 2、去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】 123456789&lt;cache/&gt;官方示例=====&gt;查看官方文档&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt;这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。 3、代码测试 所有的实体类先实现序列化接口 测试代码 123456789101112131415161718@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); session.close(); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session2.close();&#125; 结论 只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据 查出的数据都会被默认先放在一级缓存中 只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中 缓存原理图 EhCache 第三方缓存实现–EhCache: 查看百度百科 Ehcache是一种广泛使用的java分布式缓存，用于通用缓存； 要在应用程序中使用Ehcache，需要引入依赖的jar包 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt; 在mapper.xml中使用对应的缓存即可 123&lt;mapper namespace = “org.acme.FooMapper” &gt; &lt;cache type = “org.mybatis.caches.ehcache.EhcacheCache” /&gt;&lt;/mapper&gt; 编写ehcache.xml文件，如果在加载时未找到/ehcache.xml资源或出现问题，则将使用默认配置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot; updateCheck=&quot;false&quot;&gt; &lt;!-- diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下： user.home – 用户主目录 user.dir – 用户当前工作目录 java.io.tmpdir – 默认临时文件路径 --&gt; &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt; &lt;defaultCache eternal=&quot;false&quot; maxElementsInMemory=&quot;10000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;259200&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt; &lt;cache name=&quot;cloud_user&quot; eternal=&quot;false&quot; maxElementsInMemory=&quot;5000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;1800&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt; &lt;!-- defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。 --&gt; &lt;!-- name:缓存名称。 maxElementsInMemory:缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk:是否保存到磁盘，当系统当机时 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 FIFO，first in first out，这个是大家最熟的，先进先出。 LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。 LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。 --&gt;&lt;/ehcache&gt; 合理的使用缓存，可以让我们程序的性能大大提升！","categories":[],"tags":[]},{"title":"Spring笔记","slug":"Spring","date":"2021-04-01T08:39:30.789Z","updated":"2021-04-27T10:56:00.077Z","comments":true,"path":"2021/04/01/Spring/","link":"","permalink":"http://example.com/2021/04/01/Spring/","excerpt":"","text":"Spring简介Spring : 春天 —&gt;给软件行业带来了春天Spring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术官网 : http://spring.io/官方下载地址 : https://repo.spring.io/libs-release-local/org/springframework/spring/GitHub : https://github.com/spring-projects 优点1、Spring是一个开源免费的框架 , 容器 .2、Spring是一个轻量级的框架 , 非侵入式的 .3、控制反转 IoC , 面向切面 Aop4、对事物的支持 , 对框架的支持 maven导入配置在idea maven项目下,使用以下代码,放置pom.xml中进行配置 123456&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 目录Spring项目目录如下 spring配置xml配置​ beans.xml文件内容 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--bean就是java对象 , 由Spring创建和管理--&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.yun.pojo.Hello&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt; &lt;property name=&quot;id&quot; value=&quot;12156&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; test.Java 123456789101112131415161718192021import com.yun.pojo.Hello;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @Author kinlanven * @Date 2021/3/23 16:34 * @Version 1.0 */public class myTest &#123; @Test public void test()&#123; //解析beans.xml文件 , 生成管理相应的Bean对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //getBean : 参数即为spring配置文件中bean的id . Hello hello = (Hello) context.getBean(&quot;hello&quot;); hello.show(); &#125;&#125; IOC创建方式无参构造方式: IOC默认使用无参构造方法创建对象 123&lt;bean id=&quot;user&quot; class=&quot;com.yun.pojo.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 有参构造方式: IOC三种有参构造方法创建对象的方式- 123456789101112131415161718192021222324252627第一种：下标赋值 &lt;bean id=&quot;user&quot; class=&quot;com.yun.pojo.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;yun12156&quot;/&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;看风景的游客甲在看风景&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;第二种：通过类型创建 不建议使用--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.yun.pojo.User&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;看风景的游客乙在看风景&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;--&gt;第三种：直接通过参数名来设置--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.yun.pojo.User&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;看风景的游客丙在看风景&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;!-- id:bean唯一标识，相当于对象名--&gt;&lt;!-- class：bean全限定名：包＋类型--&gt;&lt;!-- name:别名：可以同时去多个别名--&gt; &lt;bean id=&quot;userT&quot; class=&quot;com.yun.pojo.UserT&quot; name=&quot;u2&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;看风景的游客丁&quot;&gt;&lt;/property&gt; &lt;property name=&quot;id&quot; value=&quot;12156&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 取别名：一对一--&gt;&lt;alias name=&quot;&quot; alias=&quot;&quot;&gt;&lt;/alias&gt;&lt;/beans&gt; 依赖注入 概念 依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 . 注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配 . 构造器注入之前 set注入​ 要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;addres&quot; class=&quot;com.yun.pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;长沙&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;student&quot; class=&quot;com.yun.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;看风景的游客甲&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; ref=&quot;addres&quot;&gt;&lt;/property&gt;&lt;!-- 数组注入--&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;!-- List注入--&gt; &lt;property name=&quot;hobbys&quot;&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;value&gt;爬山&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;!-- MAP注入--&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;中国邮政&quot; value=&quot;456456456465456&quot;/&gt; &lt;entry key=&quot;建设&quot; value=&quot;1456682255511&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;!--set注入--&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;BOB&lt;/value&gt; &lt;value&gt;COC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;!--null值注入--&gt; &lt;property name=&quot;wife&quot;&gt;&lt;null/&gt;&lt;/property&gt;&lt;!-- property注入--&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;学号&quot;&gt;20190604&lt;/prop&gt; &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt; &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;user&quot; class=&quot;com.yun.pojo.User&quot; p:name=&quot;yun&quot; p:age=&quot;12156&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 扩展方式注入1、P命名空间注入 : 需要在头文件中加入约束文件 1234导入约束 : xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;狂神&quot; p:age=&quot;18&quot;/&gt; 2、c 命名空间注入 : 需要在头文件中加入约束文件 123导入约束 : xmlns:c=&quot;http://www.springframework.org/schema/c&quot;&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;18&quot;/&gt; Bean的作用域 单例模式默认机制 123&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot;/&gt;&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;singleton&quot;/&gt; @Test public void test03(){ ApplicationContext context = new ClassPathXmlApplicationContext(“applicationContext.xml”); User user = (User) context.getBean(“user”); User user2 = (User) context.getBean(“user”); System.out.println(user==user2); } 代理模式每次从容器中get的时候都会新建一个新对象 1&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;prototype&quot;/&gt; Request当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义： 1&lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt; 针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。 Session当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义： 1&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt; 针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。 Bean的自动装配ByName自动装配12345678&lt;bean id=&quot;dog&quot; class=&quot;com.yun.pojo.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.yun.pojo.Cat&quot;/&gt;&lt;!--byname会在容器中寻找set方法后对应的名称 例:setCat bayname回去寻找cat--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.yun.pojo.User&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;看风景的游客甲&quot;&gt;&lt;/property&gt;&lt;/bean&gt; ByType自动装配123456 &lt;bean id=&quot;dog&quot; class=&quot;com.yun.pojo.Dog&quot;/&gt; &lt;bean id=&quot;cat111&quot; class=&quot;com.yun.pojo.Cat&quot;/&gt;&lt;!--byname会在容器中寻找相同的属性 例:cat111的属性为Cat--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.yun.pojo.User&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;看风景的游客甲&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 小结:​ ByName:将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。 ​ ByType:同一类型的对象，在spring容器中唯一;如果有两个bean会报错 使用注解实现自动装配依赖ApplicationContext.xml配置 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启注解--&gt; &lt;context:annotation-config/&gt; &lt;!--指定注解扫描包--&gt; &lt;context:component-scan base-package=&quot;com.yun.pojo&quot;/&gt;&lt;/beans&gt; @Autowired可以直接在类上面使用 12345678public class User &#123;// required = false可以值为空 @Autowired(required = false) private Cat cat; @Autowired private Dog dog; private String name; @Nullable表示该字段可以为空 123public User(@Nullable String name) &#123; this.name = name;&#125; @Qualifier可以通过vlaue值找到对应的id 1&lt;bean id=&quot;dog123&quot; class=&quot;com.yun.pojo.Dog&quot;/&gt; 123@Autowired@Qualifier(value =&quot;dog123&quot;)private Dog dog; @Resource1234@Resourceprivate Cat cat;@Resource(name = &quot;dog123&quot;)private Dog dog;@Autowired 小结:@Autowired:采用bytype的方式实现 @Resource:采用byname的方式实现,如果找不到就采用bytype的方式实现 使用注解开发@Component等于 @Value等于 衍生注解 @Controller：controller层 @Service：service层 @Repository：dao层 功能与@Component都一样,只是名字区分,都将装配到bean里面 使用Java的方式配置spring完全使用Java不去使用bean.xml来配置 配置com.yun.config层 12345678910111213141516171819package com.yun.config;import com.yun.pojo.User;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;//@Configuration相当于一个beans.xml@Configuration//导包@ComponentScan(&quot;com.yun.pojo&quot;)@Import(YunConfig2.class)public class YunConfig &#123; user相当于bean的id public User user()&#123; return new User(); &#125;&#125; 实体com.yun.pojo层 1234567891011121314151617package com.yun.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class User &#123; public String name; public String getName() &#123; return name; &#125;@Value(&quot;看风景的游客&quot;) public void setName(String name) &#123; this.name = name; &#125;&#125; 测试1234567891011121314151617import com.yun.config.YunConfig;import com.yun.pojo.User;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;/** * @Author kinlanven * @Date 2021/3/28 11:34 * @Version 1.0 */public class Test &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(YunConfig.class); User user = (User) context.getBean(&quot;user&quot;); System.out.println(user.getName()); &#125;&#125; 代理模式静态代理1234567891011121314151617public class UserServiceImpl implements UserService &#123; public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; public void update() &#123; System.out.println(&quot;更新了一个用户&quot;); &#125; public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031public class UserServiceProxy &#123; private UserService userService; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; public void add() &#123; log(&quot;add&quot;); userService.add(); &#125; public void delete() &#123; log(&quot;delete&quot;); userService.delete(); &#125; public void update() &#123; log(&quot;update&quot;); userService.update(); &#125; public void query() &#123; log(&quot;query&quot;); userService.query(); &#125; public void log(String msg)&#123; System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;); &#125;&#125; 抽象角色 : 一般使用接口或者抽象类来实现 真实角色 : 被代理的角色 代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 . 客户 : 使用代理角色来进行一些操作 . 动态代理ProxyInvocationHandler. java 即代理角色123456789101112131415161718192021222324252627282930import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyInvocationHandler implements InvocationHandler &#123; private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; //生成代理类 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); &#125; // proxy : 代理类 // method : 代理类的调用处理程序的方法对象. public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; log(method.getName()); Object result = method.invoke(target, args); return result; &#125; public void log(String methodName)&#123; System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;); &#125;&#125; Client . java1234567891011121314import com.yun.demo02.UserService;import com.yun.demo02.UserServiceImpl;public class Clitent &#123; public static void main(String[] args) &#123; //真实对象 UserServiceImpl userService = new UserServiceImpl(); //代理对象的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setTarget(userService); //设置要代理的对象 UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！ proxy.delete(); &#125;&#125; AOP依赖包123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 …. 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。 目标（Target）：被通知对象。 代理（Proxy）：向目标对象应用通知之后创建的对象。 切入点（PointCut）：切面通知 执行的 “地点”的定义。 连接点（JointPoint）：与切入点匹配的执行点。 使用spring 实现aop方式一使用spring api接口 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.yun.service.UserServiceImpl&quot;/&gt; &lt;bean id=&quot;log&quot; class=&quot;com.yun.log.Log&quot;/&gt; &lt;bean id=&quot;afterLog&quot; class=&quot;com.yun.log.AfterLog&quot;/&gt; &lt;!--aop的配置--&gt; &lt;aop:config&gt; &lt;!--切入点 expression:表达式匹配要执行的方法--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.yun.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; log.java12345678910111213import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;public class Log implements MethodBeforeAdvice &#123; //method : 要执行的目标对象的方法 //objects : 被调用的方法的参数 //Object : 目标对象 @Override public void before(Method method, Object[] objects, Object o) throws Throwable &#123; System.out.println( o.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;); &#125;&#125; afterlog.java12345678910111213141516import org.springframework.aop.AfterReturningAdvice;import java.lang.reflect.Method;public class AfterLog implements AfterReturningAdvice &#123; //returnValue 返回值 //method被调用的方法 //args 被调用的方法的对象的参数 //target 被调用的目标对象 @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(&quot;执行了&quot; + target.getClass().getName() +&quot;的&quot;+method.getName()+&quot;方法,&quot; +&quot;返回值：&quot;+returnValue); &#125;&#125; Test.java12345678910111213141516import com.yun.service.UserService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; @Test public void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.search();// userService.add();// userService.delete();// userService.update(); &#125;&#125; 方式二使用自定义接口 DiyPointcut.java12345678910package com.yun.diy;public class DiyPointcut &#123; public void before()&#123; System.out.println(&quot;---------方法执行前---------&quot;); &#125; public void after()&#123; System.out.println(&quot;---------方法执行后---------&quot;); &#125;&#125; 12345678910111213&lt;!-- 方式二--&gt; &lt;!--第二种方式自定义实现--&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;diy&quot; class=&quot;com.yun.diy.DiyPointcut&quot;/&gt; &lt;!--aop的配置--&gt; &lt;aop:config&gt; &lt;!--第二种方式：使用AOP的标签实现--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.yun.service.UserServiceImpl.*(..))&quot;/&gt; &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt; &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 方式三使用注解实现 AnnotationPointcut.java123456789101112131415161718192021222324252627282930package com.yun.diy;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;//标识这个类是一个切面@Aspectpublic class AnnotationPointcut &#123;//前置 @Before(&quot;execution(* com.yun.service.UserServiceImpl.*(..))&quot;) public void before()&#123; System.out.println(&quot;---------方法执行前---------&quot;); &#125;//后置 @After(&quot;execution(* com.yun.service.UserServiceImpl.*(..))&quot;) public void after()&#123; System.out.println(&quot;---------方法执行后---------&quot;); &#125;//环绕 @Around(&quot;execution(* com.yun.service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable &#123; System.out.println(&quot;环绕前&quot;); System.out.println(&quot;签名:&quot;+jp.getSignature()); //执行目标方法proceed Object proceed = jp.proceed(); System.out.println(&quot;环绕后&quot;); System.out.println(proceed); &#125;&#125; applicationContext.xml1234&lt;!--第三种方式:注解实现--&gt;&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.yun.diy.AnnotationPointcut&quot;/&gt;&lt;!--开启注解--&gt;&lt;aop:aspectj-autoproxy/&gt; 结果 整合MyBatispom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;Spring-Study&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;spring-day10-mybatis&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.13&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!-- aspectJ AOP 织入器--&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt;&lt;!-- mybatis-spring整合包 【重点--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; mybatis-config.xml1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.yun.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306?serverTimezone=UTC&amp;amp;userSSL=false&amp;amp;useUnicode=true&amp;amp;CharacterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=&quot;com.yun.dao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; MybatisUtils.java 123456789101112131415161718192021222324252627282930package com.yun.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;//sqlSessionFactary--&gt;sqlsessionpublic class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static&#123; try &#123; //使用mybatis第一步获取SQL session对象 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 //SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。 public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(); &#125;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-04-01T02:39:57.633Z","updated":"2021-04-27T10:55:37.854Z","comments":true,"path":"2021/04/01/hello-world/","link":"","permalink":"http://example.com/2021/04/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}